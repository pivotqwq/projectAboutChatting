# 数据库架构分析文档

## 项目概述

本项目是一个基于微服务架构的论坛和聊天室系统，采用了**多数据库技术栈**来满足不同业务场景的需求。项目使用了三种数据库技术：
- **PostgreSQL**（关系型数据库）
- **Redis**（内存缓存数据库）
- **MongoDB**（NoSQL文档数据库）

---

## 一、PostgreSQL（关系型数据库）

### 1.1 概述
PostgreSQL 是项目的**主要数据存储引擎**，用于存储所有结构化的业务数据。采用关系型数据库的优势在于：
- 强大的事务支持（ACID特性）
- 复杂的关系查询能力
- 数据一致性保证
- 成熟的备份和恢复机制

### 1.2 在各服务中的应用

#### 1.2.1 UserManager（用户管理服务）
**连接配置：**
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=usermanagerdb;Username=postgres;Password=***"
  }
}
```

**数据库名称：** `usermanagerdb`  
**端口：** 9291

**主要功能：**
- 存储用户账户信息（用户名、密码、手机号、邮箱等）
- 用户登录历史记录
- 用户访问失败记录（安全防护）
- 用户认证和授权数据

**核心实体：**
- `User`：用户主表
- `UserLoginHistory`：用户登录历史
- `UserAccessFail`：用户访问失败记录

**技术实现：**
- 使用 Entity Framework Core 作为 ORM
- 支持数据库迁移
- 实现了领域驱动设计（DDD）模式

---

#### 1.2.2 ForumManager（论坛管理服务）
**连接配置：**
```json
{
  "ConnectionStrings": {
    "ForumConnection": "Host=localhost;Port=5432;Database=ForumDB;Username=postgres;Password=***"
  }
}
```

**数据库名称：** `ForumDB`  
**端口：** 9292

**主要功能：**
- 存储论坛帖子内容（标题、正文、分类等）
- 帖子评论数据
- 点赞和收藏关系
- 帖子统计信息（浏览量、点赞数、评论数等）

**核心实体：**
- `Post`：帖子主表
  - `Id`：帖子ID
  - `Title`：标题
  - `Content`：内容
  - `Category`：分类（PostCategory枚举）
  - `Status`：状态（发布、草稿、删除）
  - `ViewCount`、`LikeCount`、`CommentCount`、`FavoriteCount`：统计字段
  
- `Comment`：评论表
  - `PostId`：关联帖子
  - `Content`：评论内容
  - `LikeCount`：点赞数
  
- `PostLike`：帖子点赞关联表
- `PostFavorite`：帖子收藏关联表
- `CommentLike`：评论点赞关联表

**技术实现：**
- 使用 Entity Framework Core
- 实现了复杂的关联查询（Include）
- 支持分页查询
- 实现了软删除机制

---

#### 1.2.3 MatchingService（匹配服务）
**连接配置：**
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=MatchingDB;Username=postgres;Password=***"
  }
}
```

**数据库名称：** `MatchingDB`  
**端口：** 9294

**主要功能：**
- 存储标签信息（Tag）
- 用户标签关联（UserTag）
- 用户匹配记录（UserMatch）
- 用户交互记录（UserInteraction）

**核心功能：**
- **标签管理**：创建、更新、删除标签
- **用户标签**：用户可以添加多个标签，表示兴趣和特征
- **智能匹配算法**：
  - 基于标签的匹配（权重40%）
  - 协同过滤推荐（权重30%）
  - 基于位置的匹配（权重20%）
  - 随机推荐（权重10%）
- **匹配记录**：保存匹配结果和匹配分数

**技术实现：**
- 使用 Entity Framework Core
- 实现了复杂的推荐算法
- 支持数据持久化和查询优化

---

### 1.3 PostgreSQL 的优势与适用场景

**为什么选择 PostgreSQL？**
1. **数据一致性要求高**：用户账户、帖子内容等数据需要强一致性保证
2. **复杂关系查询**：论坛帖子与评论、点赞、收藏之间的复杂关联关系
3. **事务支持**：用户注册、发帖、点赞等操作需要事务保证
4. **数据完整性**：通过外键约束保证数据的参照完整性
5. **成熟稳定**：PostgreSQL 是生产环境验证的成熟数据库

---

## 二、Redis（内存缓存数据库）

### 2.1 概述
Redis 在本项目中扮演**高性能缓存**和**实时数据存储**的角色。主要用于：
- 减轻数据库压力
- 提升响应速度
- 存储临时数据（如验证码）
- 管理在线用户状态

### 2.2 在各服务中的应用

#### 2.2.1 ChatService（聊天服务）
**连接配置：**
```json
{
  "ConnectionStrings": {
    "Redis": "localhost:6379,abortConnect=false"
  }
}
```

**主要功能：**
1. **在线用户状态管理**（PresenceService）
   ```csharp
   // 数据结构
   - "chat:online-users": Set<userId>           // 在线用户集合
   - "chat:user-conns:{userId}": Set<connectionId>  // 用户的连接ID集合
   ```
   
   **核心操作：**
   - `AddConnectionAsync`：用户连接时添加到在线集合
   - `RemoveConnectionAsync`：用户断开连接时移除
   - `IsOnlineAsync`：检查用户是否在线
   - `GetOnlineUsersAsync`：获取所有在线用户

2. **实时消息推送**
   - 发布订阅模式（Pub/Sub）
   - 在线状态变更通知
   - 支持多设备同时在线

**技术实现：**
- 使用 StackExchange.Redis 客户端
- Redis Set 数据结构存储在线用户
- 支持高并发连接管理

---

#### 2.2.2 UserManager（用户管理服务）
**连接配置：**
```json
{
  "ConnectionStrings": {
    "Redis": "localhost"
  }
}
```

**主要功能：**
1. **手机验证码缓存**（RedisPhoneCodeCache）
   ```csharp
   // 缓存键格式
   "PhoneCode:{手机号}:{邮箱}"
   ```
   
   **核心操作：**
   - `SaveCodeAsync`：保存验证码，设置过期时间
   - `RetrieveCodeAsync`：验证时读取验证码
   - `RemoveCodeAsync`：验证成功后删除验证码

2. **邮箱验证码缓存**（RedisEmailCodeCache）
   - 类似手机验证码的缓存机制
   - 防止验证码被重复使用
   - 自动过期机制（通常5-10分钟）

**安全特性：**
- 验证码有效期限制
- 防止暴力破解
- 验证后立即删除

---

#### 2.2.3 ForumManager（论坛管理服务）
**连接配置：**
```json
{
  "ConnectionStrings": {
    "Redis": "localhost:6379"
  }
}
```

**主要功能：**
1. **热门帖子缓存**（RedisForumCache）
   ```csharp
   // 缓存键示例
   "ForumManager:hot-posts"
   ```
   - 缓存热门帖子列表
   - 减少数据库查询压力
   - 提升首页加载速度

2. **帖子详情缓存**
   ```csharp
   // 缓存键格式
   "ForumManager:post:{postId}"
   ```
   - 缓存高频访问的帖子详情
   - 缓存过期自动刷新

**缓存策略：**
- 使用 `IDistributedCache` 接口
- JSON 序列化存储复杂对象
- 设置合理的过期时间
- 数据更新时清除对应缓存

**降级策略：**
- Redis 连接失败时自动切换到内存缓存（MemoryCache）
- 保证服务可用性

---

#### 2.2.4 MatchingService（匹配服务）
**连接配置：**
```json
{
  "ConnectionStrings": {
    "Redis": "localhost:6379"
  }
}
```

**主要功能：**
1. **用户推荐结果缓存**（RedisCacheService）
   ```csharp
   // 缓存键格式
   "MatchingService:recommendations:{userId}"
   ```
   - 缓存推荐算法的计算结果
   - 过期时间：5分钟（可配置）
   - 避免重复计算

2. **热门标签缓存**
   ```csharp
   "MatchingService:popular_tags"
   ```
   - 缓存高频查询的热门标签
   - 过期时间：10分钟（可配置）

3. **用户标签缓存**
   ```csharp
   "MatchingService:user_tags:{userId}"
   ```
   - 缓存用户的标签列表
   - 过期时间：15分钟（可配置）

4. **用户匹配记录缓存**
   ```csharp
   "MatchingService:user_matches:{userId}"
   ```
   - 缓存用户的匹配记录
   - 减少数据库查询

**性能优化：**
- 推荐算法计算结果缓存
- 批量缓存清除（`ClearAllUserCacheAsync`）
- 反序列化失败时自动清除缓存

---

### 2.3 Redis 的优势与适用场景

**为什么选择 Redis？**
1. **高性能**：内存存储，读写速度极快（微秒级）
2. **数据结构丰富**：支持 String、Set、Hash、List 等多种数据结构
3. **过期机制**：自动删除过期数据，适合验证码等临时数据
4. **发布订阅**：支持实时消息推送
5. **持久化选项**：可选的数据持久化（RDB/AOF）

**适用场景：**
- 短期临时数据（验证码）
- 高频查询数据（热门帖子、推荐结果）
- 实时状态数据（在线用户）
- 分布式缓存共享

---

## 三、MongoDB（NoSQL文档数据库）

### 3.1 概述
MongoDB 在本项目中专门用于**聊天消息存储**，是 ChatService 的核心存储引擎。

### 3.2 在 ChatService 中的应用

**连接配置：**
```json
{
  "ConnectionStrings": {
    "Mongo": "mongodb://localhost:27017"
  },
  "Mongo": {
    "Database": "chatdb"
  }
}
```

**数据库名称：** `chatdb`  
**集合名称：** `messages`

**主要功能：**
1. **私聊消息存储**
   ```javascript
   {
     "_id": ObjectId,
     "Type": "private",
     "FromUserId": "userId1",
     "ToUserId": "userId2",
     "Content": "消息内容",
     "CreatedAt": ISODate,
     "Status": "delivered/read"
   }
   ```

2. **群聊消息存储**
   ```javascript
   {
     "_id": ObjectId,
     "Type": "group",
     "GroupId": "groupId",
     "FromUserId": "userId",
     "Content": "消息内容",
     "CreatedAt": ISODate
   }
   ```

**技术实现：**
- 使用 MongoDB C# Driver
- BsonDocument 灵活存储消息
- 创建索引优化查询性能

**索引设计：**
```csharp
// 私聊消息索引
{ Type: 1, FromUserId: 1, ToUserId: 1, CreatedAt: 1 }

// 群聊消息索引
{ Type: 1, GroupId: 1, CreatedAt: 1 }
```

**核心操作：**
1. **插入消息**（`InsertAsync`）
   - 实时保存聊天消息
   - 异步写入，不阻塞消息发送

2. **查询私聊历史**（`GetPrivateHistoryAsync`）
   - 支持分页查询
   - 支持按时间范围查询
   - 按时间倒序排列

3. **查询群聊历史**（`GetGroupHistoryAsync`）
   - 群组消息历史
   - 分页加载
   - 时间倒序

**查询示例：**
```csharp
// 查询两个用户之间的私聊历史
public async Task<IReadOnlyList<BsonDocument>> GetPrivateHistoryAsync(
    string userA, 
    string userB, 
    DateTime? beforeUtc, 
    int pageSize)
{
    var filter = builder.Eq("Type", "private") &
                 ((builder.Eq("FromUserId", userA) & builder.Eq("ToUserId", userB)) |
                  (builder.Eq("FromUserId", userB) & builder.Eq("ToUserId", userA)));
    
    if (beforeUtc.HasValue)
    {
        filter &= builder.Lt("CreatedAt", beforeUtc.Value);
    }
    
    var sort = Builders<BsonDocument>.Sort.Descending("CreatedAt");
    var docs = await _messages.Find(filter).Sort(sort).Limit(pageSize).ToListAsync();
    docs.Reverse(); // 返回升序
    return docs;
}
```

---

### 3.3 MongoDB 的优势与适用场景

**为什么选择 MongoDB 存储聊天消息？**

1. **灵活的文档结构**
   - 不同类型的消息（文本、图片、文件）可以有不同的字段
   - 无需固定的 schema
   - 方便扩展新的消息类型

2. **高写入性能**
   - 聊天系统需要频繁写入消息
   - MongoDB 优化了写入性能
   - 支持异步写入

3. **水平扩展能力**
   - 消息数据量会持续增长
   - MongoDB 支持分片（Sharding）
   - 方便未来扩展

4. **时间序列数据**
   - 聊天消息天然按时间排序
   - MongoDB 适合存储时间序列数据
   - 支持 TTL 索引自动清理过期数据

5. **查询灵活性**
   - 支持复杂的查询条件
   - 全文搜索能力
   - 聚合管道功能强大

**不适合关系型数据库的原因：**
- 消息数据不需要复杂的关联查询
- 写入频率远高于读取频率
- 数据结构可能变化（如添加新的消息类型）
- 历史消息查询主要按时间和用户过滤

---

## 四、数据库技术选型总结

### 4.1 技术栈对比

| 数据库 | 类型 | 使用场景 | 优势 | 服务 |
|--------|------|----------|------|------|
| **PostgreSQL** | 关系型数据库 | 结构化业务数据存储 | 事务支持、数据一致性、复杂查询 | UserManager<br>ForumManager<br>MatchingService |
| **Redis** | 内存缓存 | 缓存、临时数据、实时状态 | 高性能、过期机制、发布订阅 | 所有服务 |
| **MongoDB** | NoSQL文档数据库 | 聊天消息存储 | 灵活Schema、高写入性能、水平扩展 | ChatService |

### 4.2 架构设计原则

#### 4.2.1 多数据库协同工作
项目采用**Polyglot Persistence**（多语言持久化）模式，根据不同的数据特性选择最合适的存储方案：

1. **强一致性数据** → PostgreSQL
   - 用户账户
   - 论坛帖子
   - 匹配记录

2. **临时/缓存数据** → Redis
   - 验证码
   - 在线状态
   - 查询缓存

3. **大量非结构化数据** → MongoDB
   - 聊天消息
   - 历史记录

#### 4.2.2 读写分离与缓存策略

**典型的数据流：**
```
1. 客户端请求 
   ↓
2. 先查 Redis 缓存
   ↓ (缓存未命中)
3. 查询 PostgreSQL
   ↓
4. 写入 Redis 缓存
   ↓
5. 返回客户端
```

**写操作流程：**
```
1. 写入 PostgreSQL（保证持久化）
   ↓
2. 清除或更新 Redis 缓存
   ↓
3. 返回客户端
```

#### 4.2.3 容错与降级

1. **Redis 降级策略**
   - Redis 连接失败时自动切换到内存缓存
   - 不影响核心业务功能
   - 示例代码（ForumManager/Program.cs）：
   ```csharp
   if (!string.IsNullOrEmpty(redisConnectionString))
   {
       try
       {
           builder.Services.AddStackExchangeRedisCache(options => {
               options.Configuration = redisConnectionString;
           });
       }
       catch
       {
           // Redis连接失败，使用内存缓存作为后备
           builder.Services.AddDistributedMemoryCache();
       }
   }
   ```

2. **数据一致性保证**
   - 先写数据库，后更新缓存
   - 缓存失效机制
   - 定时同步策略

---

## 五、性能优化策略

### 5.1 PostgreSQL 优化

1. **索引优化**
   - 为常用查询字段创建索引
   - 复合索引优化多条件查询
   - 定期分析和维护索引

2. **查询优化**
   - 使用 Include 预加载关联数据
   - 分页查询减少数据传输
   - 避免 N+1 查询问题

3. **连接池管理**
   - Entity Framework Core 自动管理连接池
   - 合理设置连接池大小

### 5.2 Redis 优化

1. **合理设置过期时间**
   - 验证码：5-10分钟
   - 热门帖子：30分钟
   - 推荐结果：5分钟
   - 用户标签：15分钟

2. **数据结构选择**
   - 在线用户使用 Set（高效的成员检测）
   - 简单缓存使用 String
   - 复杂对象使用 JSON 序列化

3. **内存管理**
   - 监控内存使用
   - 设置最大内存限制
   - 配置内存淘汰策略（LRU）

### 5.3 MongoDB 优化

1. **索引优化**
   - 为查询字段创建索引
   - 复合索引优化常用查询
   - 定期监控索引使用情况

2. **分页查询**
   - 使用 Limit 限制返回数量
   - 游标分页优化大数据量查询

3. **文档设计**
   - 避免文档过大
   - 合理嵌套文档结构
   - 考虑数据访问模式

---

## 六、未来扩展建议

### 6.1 数据库扩展

1. **PostgreSQL 读写分离**
   - 主从复制
   - 读写分离中间件
   - 提升查询性能

2. **Redis 集群**
   - Redis Cluster 模式
   - 主从复制
   - 哨兵模式（高可用）

3. **MongoDB 分片**
   - 按用户ID分片
   - 按时间分片
   - 提升存储容量和性能

### 6.2 监控和运维

1. **性能监控**
   - 数据库查询性能监控
   - 慢查询日志分析
   - Redis 命令监控

2. **备份策略**
   - PostgreSQL 定期全量备份
   - MongoDB 增量备份
   - Redis RDB/AOF 持久化

3. **容灾方案**
   - 多地域部署
   - 数据备份恢复演练
   - 故障转移机制

---

## 七、总结

本项目通过合理使用三种不同类型的数据库，实现了：

1. **高性能**：Redis 缓存大幅提升响应速度
2. **高可用**：多数据库冗余，降级策略保证服务稳定
3. **可扩展**：各数据库独立扩展，互不影响
4. **灵活性**：根据业务特点选择最合适的存储方案

**技术亮点：**
- ✅ 微服务架构，数据库隔离
- ✅ 多数据库协同工作
- ✅ 完善的缓存策略
- ✅ 降级和容错机制
- ✅ 领域驱动设计（DDD）
- ✅ 异步消息处理

这种多数据库架构设计充分发挥了各种数据库的优势，为系统的高性能、高可用性和可扩展性提供了坚实的基础。

---

**文档版本：** v1.0  
**更新日期：** 2025-10-21  
**作者：** AI Assistant

